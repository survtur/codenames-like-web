<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta name="viewport" content="width=device-width">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=PT+Sans+Narrow&display=swap" rel="stylesheet">

    <style>


		@import url('https://fonts.googleapis.com/css2?family=PT+Sans+Narrow&display=swap');

		#wrapper {
			font-family: 'PT Sans Narrow', sans-serif;
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			position: absolute;
			bottom: 0;
			left: 0;
			right: 0;
			top: 0;
		}

		@media screen and (orientation: portrait) {
			#wrapper.rotated {
				transform: rotate(90deg);
				transform-origin: top left;
				width: 100vh;
				height: 100vw;
				left: 100vw;
				padding-bottom: 100vh;
			}
		}


		#scores {
			display: flex;
			flex-direction: row;
		}

		#scores .score {
			flex-grow: 1;
			flex-basis: 0;
			text-align: center;
			font-size: 12vh;
		}

		#startMenu {
			display: flex;
			flex-direction: row
		}

		#blinker {
			position: fixed;
			top: 0;
			right: 0;
			font-size: 5px;
		}

		#cardField {
			display: flex;
			flex-direction: column;
			flex-wrap: nowrap;
			flex-grow: 1;
			margin: min(1vw, 1vh);
			background-color: #eee;
		}

		.cardRow {
			flex-grow: 1;
			flex-basis: 0;
			display: flex;
			flex-wrap: nowrap;
		}

		.card {
			transition: 0.1s;
			padding: 0 1vw;
			flex-grow: 1;
			flex-basis: 0;
			background-color: #f8f8f8;
			border-radius: 5px;
			margin: max(0.5vw, 0.5vh);
			color: #333;
			box-shadow: 0 0.05em 0.1em rgb(0, 0, 0, 0.4);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: min(5vw, 5vh);
			line-height: 1;
			text-transform: capitalize;
			user-select: none;
			text-align: center;
			word-wrap: anywhere;
		}

		.team-2 { background-color: black;color: #cbcbcb}
		.team-1 {color: #443; background-color: #eaead4}
		.team0 { color: #733; background-color: lightpink }
		.team1 { color: #226; background-color: lightskyblue }
		.team2 { color: #131; background-color: lightgreen }

		.bw .word {background-color: rgba(255, 255, 255, 80%);}
		.bw .team-2 .word { background-color: #000; color: #fff }
		.bw .team-1 {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAIUlEQVQYV2NkIBIwEqmOgSKF/4G2YBhAkYlYnT0ETPwPABZzAgr9qxx+AAAAAElFTkSuQmCC);}
		.bw .team0 { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAMUlEQVQYV2NkwA/+M+KR/w+UY8SlACwJ0oxNAVwSmwIUSXQFGJLICrBKwhTglAQpAAAY5AgIyRpU6AAAAABJRU5ErkJggg==);}
		.bw .team1 {background: #aaa;}


		.captain .card.opened:not(.team-2) { opacity: 0.3;}

		.captain .card .word { user-select: none;}

		.captain .card.team-1 { background: white;}

		.card:hover {
			transition: 0.1s;
			box-shadow: 0 0.01em 0.4em #000;
			filter: brightness(110%);
		}

		.card.almost {
			transition: 1s cubic-bezier(0.0, 0.4, 0.5, 0.5);
			animation: ready 0.3s infinite 1s;
			transform: perspective(12cm) rotate3d(1, 0, 0, 60deg);
			box-shadow: 0 40px 20px rgba(0, 0, 0, 70%);
		}

		@keyframes ready {
			0% { transform: perspective(12cm) rotate3d(1, 0, 0, 60deg) }
			50% { transform: perspective(12cm) rotate3d(1, 0, 0, 64deg) }
			100% { transform: perspective(12cm) rotate3d(1, 0, 0, 60deg) }
		}

		.card.opening {
			transition: 0.5s;
			transform: perspective(12cm) rotate3d(1, 0, 0, 90deg);
		}


    </style>
</head>
<body>
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

<div id="app">
    <div :class="{bw: bw, captain: isCaptain, rotated: rotated}" id="wrapper">
        <div id="blinker">
            <span :style="{color: connectionStyle}">●</span><span
                :style="{color:  unansweredCount ? 'red' : ''}">●</span>
        </div>
        <div id="gameEndPanel" v-if="state && state.winner !== null">
            WINNER: {{state.winner}}
        </div>
        <div id="startMenu">
            <div>
                <button type="button" @click="initGame">Создать игру</button>
            </div>
            <div>
                <button type="button" @click="showEnterForm = true">Войти игру</button>
                <template v-if="showEnterForm || gameName">
                    <input type="text" v-model.trim="gameName"/>
                    <button type="button" @click="joinGame(true)" :enabled="!!gameName">Капитан</button>
                    <button type="button" @click="joinGame(false)" :enabled="!!gameName">Игрок</button>
                </template>
            </div>
        </div>
        <template v-if="state">
            <div id="cardField">
                <div v-for="(row, rowIndex) in cardRows" :key="rowIndex" class="cardRow">
                    <div v-for="(card, cardIndex) in row" :key="cardIndex" class="card" :class="cardClass(card)"
                         ref="cards"
                         @mousedown="mDown(card)" @mouseup="mUp(card)" @mouseout="mOut(card)" @touchstart="mDown(card)"
                         @touchend="mUp(card)" @touchcancel="mOut(card)" @touchmove="tMove($event, cardIndex)">
                        <span class="word" :style="{fontSize: cardFontScale + '%'}"
                              style="pointer-events: none">{{card.word}}</span>
                    </div>
                </div>
            </div>
            <div id="scores">
                <div class="score team0">{{state.score[0]}}</div>
                <div class="score team1">{{state.score[1]}}</div>
            </div>
        </template>
    </div>

</div>

<script>

    const openCardSound = new Audio("data:audio/mp3;base64,/+NIxAAAAAAAAAAAAFhpbmcAAAAPAAAABAAAAtAAKioqKioqKioqKioqKioqKioqKioqKioqgICAgICAgICAgICAgICAgICAgICAgICAgNXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dX/////////////////////////////////AAAAOUxBTUUzLjEwMAIeAAAAAAAAAAAUCCQDfiIAAAgAAALQ7fkhYwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+MYxAAK2AK+eUEQAABuAAAjIB/8H+XD/////4IAgCH/V+D4Pv8HwQcJwfBwEAx+XB8Hw/9AY8PqAEEkgAAFlkSaZP/8yAXq/+MoxA8h46LSWYKQAohnMZ05a///////0ay6ksxMjZf9fRRUigZUklGSRgRYgRMoCzhZoY1AknU7rMz5FyfBrn6MyRULOBEpBTVFEmTIni8tRNEyToPUmDQuGk0ZkGdCkmXVLRdFjE4RAaBPkVMnIaTRPE0Yl0u//0MmCc/0EK3dEsGwW7qAQDv/jYJ/jEF//+MoxAohc1qBQYGoAOlU3//+ir//12dJf///6RiYHCueICRxNnyKj6/+v/80IMNUZ0bIsoL9BkcBoAACBMGoiAzenQMAwUDToAosovJrPCziMBMFgZYVYGKykBjkJf9i8Q0mTQAUNjLADAUIAANkG4gTAoNg4DBAzAx0G/8N+HOTKSKRMuTLeF4Gf////////+MYxAcMoyWAEcAoA/////////zPUrU/qVQ6KsJB4WdQGAIDHAUAQKQBgFAEOkDwBCyh0PCxuisqTEFNRTMuMTAwqqqqqqqq");

    function isTouchEventWithElement(event, element) {
        const item = event.changedTouches.item(0);
        if (element === null || item === null) return false;
        const rect = element.getBoundingClientRect();
        return rect.right > item.clientX &&
            rect.left < item.clientX &&
            rect.top < item.clientY &&
            rect.bottom > item.clientY;
    }

    const {createApp} = Vue

    const app = createApp({
        data() {
            return {
                net: {
                    websocket: null,
                    connectionState: WebSocket.CLOSED,
                    queueToSend: [],
                    sentCount: 0,
                    receivedCount: 0,
                    needConnection: false,
                },

                showEnterForm: false,
                isCaptain: false,
                gameName: window.location.hash.replace('#', ''),
                hasWinner: false,


                cardFontScale: 100,
                bw: JSON.parse(localStorage.getItem('bw') || "false"),
                rotated: JSON.parse(localStorage.getItem('rotated') || "false"),
                perRow: 5,

                state: false,
            }
        },
        computed: {
            connectionStyle() {
                if (this.net.connectionState === WebSocket.OPEN) {
                    return "#0ea21a"
                } else if (this.net.connectionState === WebSocket.CONNECTING) {
                    return "#b07b19"
                } else if (this.net.needConnection) {
                    return "#c01616"
                } else {
                    return "#000"
                }
            },
            unansweredCount() {
                return this.net.sentCount - this.net.receivedCount
            },
            shouldSend() {
                return this.net.queueToSend.length + this.net.connectionState;
            },
            cardRows() {
                const rows = [];
                let start = 0;
                while (start < this.state.cards.length) {
                    let end = start + this.perRow;
                    rows.push(this.state.cards.slice(start, end))
                    start = end
                }
                return rows
            }
        },
        methods: {
            mDown(card) {
                console.log("DOWN: " + card.word);
                if (!card.is_opened) {
                    card.almost = true;
                    card.mouseDownStart = new Date();
                }
            },
            mOut(card) {
                console.log("OUT: " + card.word);
                card.almost = false;
                card.mouseDownStart = false;
            },
            mUp(card) {
                console.log("UP: " + card.word)
                if (card.mouseDownStart) {
                    const deltaMs = new Date() - card.mouseDownStart;
                    if (deltaMs > 1000) {
                        this.openCard(card);
                    }
                }
                card.almost = false;
            },
            tMove(e, i) {
                if (!isTouchEventWithElement(e, this.$refs.cards[i])) {
                    this.mOut(this.state.cards[i])
                }
            },
            cardClass(c) {
                const cls = []
                if (c.is_opened) {
                    cls.push('opened')
                }
                if (c.is_opening) {
                    cls.push('opening')
                }
                if (c.just_opened) {
                    cls.push('just-opened')
                }

                if (c.is_opened || this.isCaptain) {
                    cls.push('team' + c.team)
                }

                if (c.almost) {
                    cls.push('almost')
                }
                return cls.join(" ")
            },
            initGame() {
                const rules = {cards_set: 0, cards_count: 25, team_cards_count: [9, 8,]};
                this.net.needConnection = true;
                this.net.queueToSend.push(JSON.stringify({action: 'init', rules: rules}));
            },
            joinGame(asCap) {
                this.isCaptain = asCap;
                this.net.needConnection = true;
                this.net.queueToSend.push(JSON.stringify({action: 'join', game: this.gameName}))
            },
            openCard(card) {
                if (card.is_opened) {
                    return
                }
                const i = this.state.cards.indexOf(card);
                card.is_opening = true;
                openCardSound.play()
                setTimeout(() => {
                    card.is_opening = false;
                    card.is_opened = true;
                }, 500)
                this.net.queueToSend.push(JSON.stringify({action: 'open', card: i, game: this.gameName}))
            },
            connectWs() {
                const wsPotocol = location.protocol === 'https:' ? 'wss:' : 'ws:'
                this.net.websocket = new WebSocket(wsPotocol + "//localhost:8000/ws");
                this.net.connectionState = WebSocket.CONNECTING;
                this.net.websocket.onopen = () => {
                    this.net.connectionState = this.net.websocket.readyState;
                }
                this.net.websocket.onmessage = (event) => {
                    this.net.receivedCount++;
                    this.parseMessage(event.data)
                };
                this.net.websocket.onclose = (e) => {
                    console.info("Connection closed")
                    this.net.connectionState = this.net.websocket.readyState;
                }
            },
            parseMessage(s) {
                const data = JSON.parse(s)
                if (!data.success) {
                    console.error(data)
                }

                if (data.action === 'init') {
                    this.gameName = data.game
                    this.showEnterForm = true
                    window.location.hash = data.game
                } else if (data.action === 'state') {
                    this.state = data.state
                    this.gameName = data.game
                    window.location.hash = data.game
                }

            }
        },
        watch: {
            shouldSend() {
                if (this.net.queueToSend.length === 0) {
                    return
                }
                if (this.net.connectionState === WebSocket.OPEN) {
                    this.net.websocket.send(this.net.queueToSend.shift());
                    this.net.sentCount++;
                } else if (this.net.connectionState === WebSocket.CLOSED && this.net.needConnection) {
                    this.connectWs();
                }
            },
            hasWinner(v) {
                if (v) {
                    this.net.needConnection = false;
                    this.net.websocket.close()
                }
            },
            bw(v) {
                localStorage.setItem('bw', JSON.stringify(v))
            },
            rotated(v) {
                localStorage.setItem('rotated', JSON.stringify(v))
            }
        },
    });
    app.mount('#app')
</script>

</body>
</html>